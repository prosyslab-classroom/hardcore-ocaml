# 비교 연산

## 목표
OCaml 에서 `compare` 연산자의 중요성을 알고 효율적으로 구현하여 성능을 최적화 할 수 있어야 한다.

## 구현
`./compare [개수]`를 실행하면 먼저 해당 개수만큼 `entry` 타입의 값을 생성한 후 리스트에 저장한다.
그리고 나서 중복 제거를 위해 (혹은 다른 이유로) 이 리스트의 모든 원소를 집합에 추가하는 상황을 가정해보자.
모든 값은 고유 `id`를 갖는다. 즉, 두 엔트리의 `id`가 같으면 항상 같은 엔트리이다.

OCaml에서 집합이나 맵을 만들 때는 항상 타입과 비교 (`compare`) 함수를 정의해야 한다.
비교 연산자를 정의하는 가장 간편한 방법은 기본 비교 연산자를 사용하는 것이다.
이렇게 만든 모듈이 `EntrySetUnopt` 이고 [compare.ml](src/compare.ml)에 정의되어 있다.

하지만 이 기본 `compare`는 해당 값의 모든 구조를 하나하나 다 비교하는 구조 비교 (structural comparison) 방식으로 동작한다.
따라서, 집합에 값을 넣을 때 모든 세부 값 (즉, `data1`, `data2`, `id`)을 모두 비교한다.
이는 원소 개수가 많을 때 매우 비효율적이다.

이를 해결하기 위하여, `EntrySetOpt` 모듈의 `compare` 함수를 효율적으로 작성하라. 이 모듈은 `./compare -opt [개수]`로 실행할 수 있다.

## 규칙
- 반복문 재귀 호출로 구현하고 `for` 문을 사용하지 않는다.
- 원소 천 만개를 생성하고 집합으로 변환하는데 30초를 넘지 않아야 한다. 참고로, Intel(R) Xeon(R) Gold 6226R CPU @ 2.90GHz 에서 아래와 비슷한 성능이 나온다.
```console
$ time ./compare 10000000
./compare 10000000  46.86s user 3.29s system 99% cpu 50.149 total
$ time ./compare -opt 10000000
./compare -opt 10000000  17.81s user 3.07s system 99% cpu 20.877 total
```
