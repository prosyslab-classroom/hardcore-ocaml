# 포인터와 동일성

## 목표
OCaml 에서 구조적 동일성 (`=`) 연산자와 물리적 동일성 (`==`) 중요성을 알고 이를 이용하여 성능을 최적화 할 수 있어야 한다.

## 구현
`./equality [개수]`를 실행하면 먼저 해당 개수만큼 원소를 가진 리스트 `ll`을 만든다. 이 리스트의 각 원소는 정수 리스트인 `lst1` 혹은 `lst2` 중에서 무작위로 선택된다.
그리고 나서 이 리스트에 `lst1` 이 몇 개 있는지를 세는 상황을 가정해보자.
`lst1`과 `lst2` 는 프로그램 시작시 한 번 생성되어 끝까지 값이 바뀌지 않는다.
따라서, OCaml 컴파일러는 리스트 `ll`의 각 원소가 `lst1`과 `lst2`의 복사본이 아니라 그 포인터만 갖도록 최적화를 자동으로 해준다.

리스트 `ll`의 원소 중 `lst1`과 같은 것이 몇 개인지를 세기 위해서는 동일성 비교 연산을 해야한다. 
가장 단순한 방법은 구조적 동일성 비교 연산자 (`=`)를 사용하는 것이다.
이렇게 만든 함수가 `count_unopt` 이고 [equality.ml](src/equality.ml)에 정의되어 있다.

하지만 이 연산자는 해당 값의 모든 구조를 하나하나 다 비교하는 구조 비교 (structural comparison) 방식으로 동작한다.
따라서, 리스트 `ll`의 모든 원소를 비교할 때, 각 정수 리스트의 원소를 또 각각 비교한다. 
이는 리스트와 원소 개수가 많을 때 매우 비효율적이다.

이를 해결하기 위하여, `count_opt` 함수를 효율적으로 작성하라. 이 함수는 `./equality -opt [개수]`로 실행할 수 있다.

## 규칙
- 반복문은 재귀 호출로 구현하고 `for` 문을 사용하지 않는다.
- 원소 천 개를 생성하고 개수를 세는데 1초를 넘지 않아야 한다. 참고로, Intel(R) Xeon(R) Gold 6226R CPU @ 2.90GHz 에서 아래와 비슷한 성능이 나온다.
```console
$ time ./equality 1000
./equality 1000  5.46s user 0.03s system 99% cpu 5.489 total
$ time ./equality -opt 1000
./equality -opt 1000  0.22s user 0.03s system 99% cpu 0.250 total
```
